(*******************************************************************************
* Copyright (c) 2015 IBM Corp.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************)

class Loader usingPlatform: platform andJSON: JSON = Value (
  | 
    private Vector = platform kernel Vector.
    private File = platform files.
    private FilePath = File FilePath.
    private Dictionary = platform collections Dictionary.
    private JSON = JSON.
  |
) (
  public class Loader new: loadUtil = (
    | loaderSettings 
      loadUtil = loadUtil.
      DATABASE_PARALLELISM = 5.
      nowAtMidnight
      customers = Vector new.
      airportCodeMappings = Vector new.
      flightSegments = Vector new.
      flights = Vector new.
    |
      loaderSettings:: readLoaderSetting
      
      (*nowatmignifht:: getDateAtTwelveAM(new Date());*)

      (*make parallelism actors and have them insert the data*)

      (*
      var customerQueue = async.queue(insertCustomer, DATABASE_PARALLELISM);
      customerQueue.drain = function() {
        logger.info('all customers loaded');
        airportCodeMappingQueue.push(airportCodeMappings);
      }
      
      var airportCodeMappingQueue = async.queue(insertAirportCodeMapping, DATABASE_PARALLELISM);
      airportCodeMappingQueue.drain = function() {
        logger.info('all airportMappings loaded');
        flightSegmentsQueue.push(flightSegments);
      }
      
      var flightSegmentsQueue = async.queue(insertFlightSegment, DATABASE_PARALLELISM);
      flightSegmentsQueue.drain = function() {
        logger.info('all flightSegments loaded');
        flightQueue.push(flights);
      }

      var flightQueue = async.queue(insertFlight, DATABASE_PARALLELISM);
      
      *)
  ) (

    public class Customer new: id = (
      |
        public _id ::= id.
        public password ::= 'password'.
        public status ::= 'GOLD'.
        public total_miles ::= 1000000.
        public miles_ytd ::= 1000.
        public address ::= Address new.
        public phoneNumber ::= '919-123-4567'.
        public phoneNumberType ::= 'BUSINESS'.
      |
    )(
      toJSON = (
        
      )
    ) : (
      fromJSON: json = (
        | entries result |
        result:: Customer new: ''.
        entries:: JSON JsonParser parse: json.
        entries do: [ :e |
          e key = '_id' ifTrue: [^ result _id: e value].
          e key = 'password' ifTrue: [^ result password: e value].
          e key = 'status' ifTrue: [^ result status: e value].
          e key = 'total_miles' ifTrue: [^ result total_miles: e value].
          e key = 'miles_ytd' ifTrue: [^ result miles_ytd: e value].
          e key = 'address' ifTrue: [
            e value do: [ :ee |
              ee key = 'streetAddress1' ifTrue: [ ^ result address streetAddress1: ee value].
              ee key = 'city' ifTrue: [ ^ result address city: ee value].
              ee key = 'stateProvince' ifTrue: [ ^ result address stateProvince: ee value].
              ee key = 'country' ifTrue: [ ^ result address country: ee value].
              ee key = 'postalCode' ifTrue: [ ^ result address postalCode: ee value].
            ].
            ^ self.
          ].
          e key = 'phoneNumber' ifTrue: [^ result phoneNumber: e value].
          e key = 'phoneNumberType' ifTrue: [^ result phoneNumberType: e value].
        ]
      )
    )

    public class Address = (
      |
      public streetAddress1 ::= '123 Main St.'.
      public city ::= 'Anytown'.
      public stateProvince ::= 'NC'.
      public country ::= 'USA'.
      public postalCode ::= '27617'.
      |
    )()

    public class AirportCodeMapping from: id to: name = (
      |
        public _id ::= id.
        public airportName ::= name.
      |
    )() : (
      fromJSON: json = (
        | entries result |
        result:: AirportCodeMapping from: '' to: ''.
        entries:: JSON JsonParser parse: json.
        entries do: [ :e |
          e key = '_id' ifTrue: [^ result _id: e value].
          e key = 'airportName' ifTrue: [^ result airportName: e value].
        ]
      )
    )

    public class FlightSegment new: id from: origin to: destination with: miles = (
      |
        public _id ::= id.
        public originPort ::= origin.
        public destPort ::= destination.
        public miles ::= miles.
      |
    )() : (
      fromJSON: json = (
        | entries result |
        result:: FlightSegment new: '' from: '' to: '' with: 0.
        entries:: JSON JsonParser parse: json.
        entries do: [ :e |
          e key = '_id' ifTrue: [^ result _id: e value].
          e key = 'originPort' ifTrue: [^ result originPort: e value].
          e key = 'destPort' ifTrue: [^ result destPort: e value].
          e key = 'miles' ifTrue: [^ result miles: e value].
        ]
      )
    )

    public class Flight new: id segment: segment departure: departure arrival: arrival = (
      |
        public _id ::= id.
        public flightSegmentId ::= segment.
        public scheduledDepartureTime ::= departure.
        public scheduledArrivalTime ::= arrival.
        public firstClassBaseCost ::= 500.
        public economyClassBaseCost ::= 200.
        public numFirstClassSeats ::= 10.
        public numEconomyClassSeats ::= 200.
        public airplaneTypeId ::= 'B747'.
      |
    )() : (
      fromJSON: json = (
        | entries result |
        result:: Flight new: '' segment: '' departure: '' arrival: ''.
        entries:: JSON JsonParser parse: json.
        entries do: [ :e |
          e key = '_id' ifTrue: [^ result _id: e value].
          e key = 'flightSegmentId' ifTrue: [^ result flightSegmentId: e value].
          e key = 'scheduledDepartureTime' ifTrue: [^ result scheduledDepartureTime: e value].
          e key = 'scheduledArrivalTime' ifTrue: [^ result scheduledArrivalTime: e value].
          e key = 'firstClassBaseCost' ifTrue: [^ result firstClassBaseCost: e value].
          e key = 'economyClassBaseCost' ifTrue: [^ result economyClassBaseCost: e value].
          e key = 'numFirstClassSeats' ifTrue: [^ result numFirstClassSeats: e value].
          e key = 'numEconomyClassSeats' ifTrue: [^ result numEconomyClassSeats: e value].
          e key = 'airplaneTypeId' ifTrue: [^ result airplaneTypeId: e value].
        ]
      )
    )

    getDepartureTime: days from: date = (
      | milliseconds |
      milliseconds:: days * 24 * 60  * 60  * 1000.
      (*return new Date(baseTime.getTime() + milliseconds).
      *)
    )

    getArrivalTime: departureTime mileage: mileage = (
      | averageSpeed hours milliseconds |
      averageSpeed:: 600.0. (* 600 miles/hours *)
      hours:: (mileage / averageSpeed). (* miles / miles/hour = hours *)
      milliseconds:: hours * 60 * 60 * 1000.
      (*return new Date(departureTime.getTime() + milliseconds);
      *)
    ) 

    getDateAtTwelveAM: theDate = (
      (*return new Date(theDate.getFullYear(), theDate.getMonth(), theDate.getDate(), 0, 0, 0, 0);*) 
    )

    getDateAtRandomTopOfTheHour: theDate = (
      (*
      randomHour = Math.floor((Math.random()*23));
      return new Date(theDate.getFullYear(), theDate.getMonth(), theDate.getDate(), randomHour, 0, 0, 0);
      *)
    )

    insertCustomer: customer callback: callback = (
      (* logger.debug('customer to insert = ' + JSON.stringify(customer));*)
      loadUtil insertOne: #n_customer doc: customer callback: [ :err :customerInserted |
        (*logger.debug('customer inserted = ' + JSON.stringify(customerInserted));*)
        callback value.
      ]
    )

    insertAirportCodeMapping: airportCodeMapping callback: callback = (
      loadUtil insertOne: #n_airportCodeMapping doc: airportCodeMapping callback: [ :err :airportCodeMappingInserted |
        (*logger.debug('airportCodeMapping inserted = ' + JSON.stringify(airportCodeMappingInserted));*)
        callback value.
      ]
    )

    insertFlightSegment: flightSegment callback: callback = (
      loadUtil insertOne: #n_flightSegment doc: flightSegment callback: [ :err :flightSegmentInserted|
        (*logger.debug('flightSegment inserted = ' + JSON.stringify(flightSegmentInserted));*)
        callback value.
      ]
    )

    insertFlight: flight callback: callback = (
      loadUtil insertOne: #n_flight doc: flight callback: [ :err :flightInserted |
        (*logger.debug('flight inserted = ' + JSON.stringify(flightInserted));*)
        callback value.
      ]
    )

    public startLoadDatabase: req res: res = (
      | numCustomers |
      customers size >= 1 ifTrue:[
        res send: 'Already loaded'.
        ^ self.
      ].
      
      numCustomers:: req query numCustomers.
      (*if undefined*)
      numCustomers ifNil: [
        numCustomers:: loaderSettings at: #MAX_CUSTOMERS.
      ].

      (*logger.info('starting loading database');*)
      createCustomers: numCustomers.
      createFlightRelatedData: [
        (*logger.info('number of customers = ' + customers.length);
        logger.info('number of airportCodeMappings = ' + airportCodeMappings.length);
        logger.info('number of flightSegments = ' + flightSegments.length);
        logger.info('number of flights = ' + flights.length);*)
        flightQueue drain = [
          (*logger.info('all flights loaded');
          logger.info('ending loading database');*)
          res send: 'Database Finished Loading'.
        ].
        customerQueue push: customers.
      ].
    )

    public getNumConfiguredCustomers = (
      ^ [ :req :res |
        res contentType: 'text/plain'.
        res send: ((loaderSettings at: #MAX_CUSTOMERS) asString). 
      ]
    )

    createCustomers: numCustomers = (
      0 to: (numCustomers - 1) do: [ :ii | | customer |
        customer:: Customer new: ('uid' + ii + '@email.com').
        customers append: customer.
      ]
    )

    createFlightRelatedData: callback = (
      | rows airportCodeMapping flightSegmentId|
      rows:: Vector new.

      rows:: parseCSV: './loader/mileage.csv'.
      
      (*logger.debug('Number of lines: ' + count);
      logger.debug('rows.length = ' + rows.length);
      logger.debug('rows = ' + rows);*)
      1 to: ((rows at: 1) length) do: [ :ii |
        airportCodeMapping:: AirportCodeMapping from: ((rows at: 2) at: ii) to: ((rows at: 1) at: ii).
        airportCodeMappings append: (airportCodeMapping).
      ].
      
      flightSegmentId:: 0.

      (* actual mileages start on the third row*)
      3 to: (rows length) do: [ :ii |
        | fromAirportCode |
        fromAirportCode:: ((rows at: ii) at: 2).
        (*) format of the row is "long airport name name" (0), "airport code" (1), mileage to first airport in rows 0/1 (2), mileage to second airport in rows 0/1 (3), ... mileage to last airport in rows 0/1 (length)*)
        3 to: ((rows at: ii) length) do: [ :jj |
          | toAirportCode flightSegment mileage |
          toAirportCode:: ((rows at: 2) at: (jj - 3)).
          mileage:: ((rows at: ii) at: jj).
          mileage = 'NA' ifFalse: [
            flightSegment:: FlightSegment new: ('AA' + flightSegmentId) from: fromAirportCode to: toAirportCode with: mileage.
            flightSegmentId:: flightSegmentId + 1.
            flightSegments append: flightSegment.
            
            0 to: (loaderSettings at: #MAX_DAYS_TO_SCHEDULE_FLIGHTS) do: [ :kk |
              0 to: (loaderSettings at: #MAX_FLIGHTS_PER_DAY) do: [ :ll |
                | flight |
                flight:: Flight new: (uuid v4) segment: (flightSegment _id) departure: (getDepartureTime: kk from: nowAtMidnight) arrival: (getArrivalTime: (flight scheduledDepartureTime) mileage: mileage).
                flights push: flight.
              ]
            ]
          ]
        ].
      ].
      callback value.
    )

    readLoaderSetting = (
      | cis settings fp|
      settings:: Dictionary new.
      cis:: (FilePath for: './loader/loader-settings.json') charInputStream.
      (JSON JSONParser parse: (cis next: (cis size))) do: [ :e |
        settings at: (e key asSymbol) put: (e value).
      ]. 
      ^ settings.
    )


    parseCSV: filepath <String> ^ <Vector[Vector[String]]> = (
      | path cis rows line |
      path:: (Files FilePath for: filepath).
      cis:: path charInputStream.
      rows:: (Vector new: 10).

      [ cis atEnd ] whileFalse: [
        rows append: ((cis upTo: '\n') split: ',').
      ].
      cis close.
      ^ rows.
    )
  )
)