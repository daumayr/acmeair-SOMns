(*******************************************************************************
* Copyright (c) 2015 IBM Corp.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************)

class DataAccess usingPlatform: platform = Value (
	|
		Derby = platform derby.
		Dictionary = platform collections Dictionary.
		mongodb = nil. (*TODO replace with my own databse*)
	|
) (
  public class DataAccess = (
    |
      dbclient
			public dbNames = Dictionary new: 6.
    |

		dbNames at: 'customerName' put: 'n_customer'.
		dbNames at: 'flightName' put: 'n_flight'.
		dbNames at: 'flightSegmentName' put: 'n_flightSegment'.
		dbNames at: 'bookingName' put: 'n_booking'.
		dbNames at: 'customerSessionName' put: 'n_customerSession'.
		dbNames at: 'airportCodeMappingName' put: 'n_airportCodeMapping'.

  )(

		(*var upsertStmt ={
			"n_customer": "INSERT INTO n_customer (id,content) values (?, ?)",
			"n_customerSession": "INSERT INTO n_customerSession (id,content) values (?, ?)",
			"n_booking": "INSERT INTO n_booking (customerId,id,content) values (?, ?, ?)",
			"n_flight": "INSERT INTO n_flight (flightSegmentId,scheduledDepartureTime,id,content) values (?, ?, ?, ?)",
			"n_flightSegment": "INSERT INTO n_flightSegment (originPort,destPort,id,content) values (?, ?, ?,?)",
			"n_airportCodeMapping": "INSERT INTO n_airportCodeMapping (id,content) values (?, ?)"
		}
		
		var findByIdStmt = {
				"n_customer": "SELECT content from n_customer where id=?",
				"n_customerSession": "SELECT content from n_customerSession where id=?",
				"n_airportCodeMapping": "SELECT content from n_airportCodeMapping where id=?"
		}*)

    public initializeDatabaseConnections: callback = (
			| client |
			
			client:: Derby getConnection: 'acmeair'.
			
			(* TODO error handling for connection
			client.connect(function(err, result) {
				logger.info('Connected.');
				dbclient = client;
				callback(null);
			});*)
    )

    public insertOne: collectionname doc: doc callback: callback = (
      (*dbclient.execute(upsertStmt[collectionname], getUpsertParam(collectionname,doc), {prepare: true}, function(err) {
			  if (err) {callback(err, null);}
			  else {callback(null, doc);}
			});*)
    )

    public findOne: collectionname key: key callback: callback = (
			| query |
			
      query:: findByIdStmt at: collectionname.
			query ifNil: [
				callback value: ('FindById not supported on '+collectionname) with: nil.
				^ self.
			].
			(*prepare true*)
			dbclient execute: query args: { key } callback: [ :err :result |
				err ifNil: [callback value: nil with: JSON parse: ((result rows at: 0) content)]
				ifNotNil: [ callback value: err with: nil].
			]
    )

    public update: collectionname doc: doc callback: callback = (
      (*dbclient.execute(upsertStmt[collectionname], getUpsertParam(collectionname,doc), {prepare: true}, function(err) {
			  if (err) {callback(err, null);}
			  else {callback(null, doc);}
		});*)
    )

    public remove: collectionname condition: condition callback: callback = (
      (*
      var info = getQueryInfo(collectionname, condition)
			var query = "DELETE from "+collectionname+" where "+ info.whereStmt;
			logger.debug("query:"+query +", param:"+ JSON.stringify(info.param))
			dbclient.execute(query, info.param, {prepare: true},function(err, result) {
				if(err) {callback(err)}
				else {callback (null)}
			});
      *)
    )

    public findBy: collectionname condition: condition callback: callback = (
      (*
      var info = getQueryInfo(collectionname, condition)
			var query = "SELECT content from "+collectionname+" where "+ info.whereStmt;
			logger.debug("query:"+query +", param:"+ JSON.stringify(info.param))
			dbclient.execute(query, info.param,{prepare: true}, function(err, result) {
				if(err) {callback(err, null)}
				else {
					var docs = [];
					for (var i = 0; i < result.rows.length; i++) {
						logger.debug("result["+i +"]="+ JSON.stringify(result.rows[i]));
						docs.push(JSON.parse(result.rows[i].content));
					}		
					callback (null, docs)
				}
			});
      *)
    )

    public count: collectionname condition: condition callback: callback = (
      (*
      dbclient.collection(collectionname,function(error, collection){
			  if (error){
				  logger.error("count hit error:"+error);
				  callback(error, null);
			  }
			  else{
				collection.count(condition, function (err, count) {
					if (err) callback (err, null);
					else callback(null, count);
				});
			  }
		});
      *)
    )

    getUpsertParam: collectionname doc: doc = (
(*)		if (collectionname === 'n_booking' )
			return [doc.customerId, doc._id, JSON.stringify(doc)];
		if (collectionname === 'n_flight')
			return [doc.flightSegmentId, doc.scheduledDepartureTime, doc._id, JSON.stringify(doc)];
		if (collectionname ==='n_flightSegment')
			return [doc.originPort, doc.destPort, doc._id, JSON.stringify(doc)];
		return [doc._id, JSON.stringify(doc)];*)

		)

		getQueryInfo: collectionname condition: condition = (
		(*var param = [];
		var whereStmt =""
		var first = true;
		for (var key in condition) {
			if (!first) whereStmt +=" and ";
			if (key === '_id')
				whereStmt += "id=?";
			else
				whereStmt += key +"=?";
			first = false;
			param.push(condition[key]);
		}
		return {"whereStmt":whereStmt, "param":param};*)
		)
  )
  
)