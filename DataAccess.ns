(*******************************************************************************
* Copyright (c) 2015 IBM Corp.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************)

class DataAccess usingPlatform: platform = Value (
	|
		Derby = platform derby.
		Dictionary = platform collections Dictionary.
	|
) (
  public class DataAccess = (
    |
      dbclient
			public insertStmt = Dictionary new: 6.
			public updateStmt = Dictionary new: 6.
			public findByIdStmt = Dictionary new: 3.
    |
  )(

    public initializeDatabaseConnections: callback = (
			dbclient:: Derby getConnection: 'acmeair'.
			callback value: nil.
			(* TODO error handling for connection
			logger.info('Connected.');
			*)

			insertStmt at: #n_customer put: (dbclient prepareStatement:'INSERT INTO n_customer (id,content) values (?, ?)').
			insertStmt at: #n_customerSession put: (dbclient prepareStatement: 'INSERT INTO n_customerSession (id,content) values (?, ?)').
			insertStmt at: #n_booking put: (dbclient prepareStatement: 'INSERT INTO n_booking (customerId,id,content) values (?, ?, ?)').
			insertStmt at: #n_flight put: (dbclient prepareStatement: 'INSERT INTO n_flight (flightSegmentId,scheduledDepartureTime,id,content) values (?, ?, ?, ?)').
			insertStmt at: #n_flightSegment put: (dbclient prepareStatement: 'INSERT INTO n_flightSegment (originPort,destPort,id,content) values (?, ?, ?,?)').
			insertStmt at: #n_airportCodeMapping put: (dbclient prepareStatement: 'INSERT INTO n_airportCodeMapping (id,content) values (?, ?)').
			 
			updateStmt at: #n_customer put: (dbclient prepareStatement:'UPDATE n_customer SET content = ? WHERE id=?').
			updateStmt at: #n_customerSession put: (dbclient prepareStatement: 'UPDATE n_customerSession SET content = ? WHERE id=?').
			updateStmt at: #n_booking put: (dbclient prepareStatement: 'UPDATE n_booking SET content = ? WHERE customerId = ? AND id=?').
			updateStmt at: #n_flight put: (dbclient prepareStatement: 'UPDATE n_flight SET content = ? WHERE flightSegmentId = ? AND scheduledDepartureTime = ? AND id=?').
			updateStmt at: #n_flightSegment put: (dbclient prepareStatement: 'UPDATE n_flightSegment SET content = ? WHERE originPort = ? AND destPort = ? AND id=?').
			updateStmt at: #n_airportCodeMapping put: (dbclient prepareStatement: 'UPDATE n_airportCodeMapping SET content = ? WHERE id=?').

			findByIdStmt at: #n_customer put: 'SELECT content from n_customer where id=?'.
			findByIdStmt at: #n_customerSession put: 'SELECT content from n_customerSession where id=?'.
			findByIdStmt at: #n_airportCodeMapping put: 'SELECT content from n_airportCodeMapping where id=?'.
    )

		private prepareDB = (
			| query |
			query:: '
			CREATE TABLE n_airportcodemapping(
				id LONG VARCHAR PRIMARY KEY,
				content LONG VARCHAR
				);

			CREATE TABLE n_booking(
				customerId LONG VARCHAR,
				id LONG VARCHAR,
				content LONG VARCHAR,
				PRIMARY KEY (customerId, id)
				);

			CREATE TABLE n_customer(
				id LONG VARCHAR PRIMARY KEY,
				content LONG VARCHAR
				);

			CREATE TABLE n_customersession(
				id LONG VARCHAR PRIMARY KEY,
				content LONG VARCHAR
				);

			CREATE TABLE n_flight(
				flightSegmentId LONG VARCHAR,
				scheduledDepartureTime timestamp,
				id LONG VARCHAR,
				content LONG VARCHAR,
				PRIMARY KEY (flightSegmentId,scheduledDepartureTime,id)
				);

			CREATE TABLE n_flightsegment(
				originPort LONG VARCHAR,
				destPort LONG VARCHAR,
				id LONG VARCHAR,
				content LONG VARCHAR,
				PRIMARY KEY (originPort,destPort,id)
				);'.
				
			dbclient execute: query callback: [ :err :result |
				result println.
			]
		)

    public insertOne: collectionname doc: doc callback: callback = (
			(insertStmt at: collectionname) execute: (getInsertParam: collectionname doc: doc) callback: [ :err :result |
				err ifNil: [
					callback value: nil with: doc.
				] ifNotNil: [
					callback value: err with: nil.
				] 
			]
    )

    public findOne: collectionname key: key callback: callback = (
			| query |
			
      query:: findByIdStmt at: collectionname.
			query ifNil: [
				callback value: ('FindById not supported on '+collectionname) with: nil.
				^ self.
			].
			(*prepare true*)
			query execute: { key } callback: [ :err :result |
				err ifNil: [
					callback value: nil with: (JSON parse: ((result rows at: 0) content))
				] ifNotNil: [ 
					callback value: err with: nil
				]
			]
    )

    public update: collectionname doc: doc callback: callback = (
			(updateStmt at: collectionname) execute: (getUpdateParam: collectionname doc: doc) callback: [ :err :result |
				err ifNil: [
					callback value: nil with: doc.
				] ifNotNil: [
					callback value: err with: nil.
				] 
			]
    )

    public remove: collectionname condition: condition callback: callback = (
      | info query |
			info:: getQueryInfo: collectionname condition: condition.
			
			query:: 'DELETE from '+collectionname+ ' where '+ (info whereStmt).
			(*logger.debug("query:"+query +", param:"+ JSON.stringify(info.param))*)
			(dbclient prepareStatement: query) execute: (info param) callback: [ :err :result |
				err ifNil: [
					callback value: nil.
				] ifNotNil: [
					callback value: err.
				] 
			]
    )

    public findBy: collectionname condition: condition callback: callback = (
      | info query |
			info:: getQueryInfo: collectionname condition: condition.
			
			query:: 'SELECT content from '+collectionname+ ' where '+ (info whereStmt).
			(*logger.debug("query:"+query +", param:"+ JSON.stringify(info.param))*)
			(dbclient prepareStatement: query) execute: (info param) callback: [ :err :result |
				|docs|
				err ifNil: [
					docs:: Vector new.
					1 to: (result size) do: [ :i |
						(*logger.debug("result["+i +"]="+ JSON.stringify(result.rows[i]));*)
						docs append: (JSON parse: ((result at: i) content))
					].
					callback value: nil with: docs.
				] ifNotNil: [
					callback value: err with: nil.
				] 
			] 
    )

    public count: collectionname condition: condition callback: callback = (
			| query |
			query:: 'SELECT COUNT(*) from '+collectionname+ ' where '+ condition.
			dbclient execute: query callback: [ :err :count |
				err ifNil: [
					callback value: nil with: count.
				] ifNotNil: [
					(*logger.error("count hit error:"+error);*)
					callback value: err with: nil.
				] 
			]
    )

    getInsertParam: collectionname doc: doc = (
			collectionname = #n_booking ifTrue: [
				^ {doc customerId . doc _id . (JSON stringify: doc)}
			].

			collectionname = #n_flight ifTrue: [
				^ {doc flightSegmentId . doc scheduledDepartureTime . doc _id . (JSON stringify: doc)}
			].

			collectionname = #n_flightSegment ifTrue: [
				^ {doc originPort . doc destPort . doc _id . (JSON stringify: doc)}
			].
			
			^ {doc _id . (JSON stringify: doc)}
		)

		getUpdateParam: collectionname doc: doc = (
			collectionname = #n_booking ifTrue: [
				^ {(JSON stringify: doc) . doc customerId . doc _id}
			].

			collectionname = #n_flight ifTrue: [
				^ {(JSON stringify: doc) . doc flightSegmentId . doc scheduledDepartureTime . doc _id }
			].

			collectionname = #n_flightSegment ifTrue: [
				^ {(JSON stringify: doc) . doc originPort . doc destPort . doc _id }
			].
			
			^ {(JSON stringify: doc) . doc _id }
		)

		getQueryInfo: collectionname condition: condition = (
		(*var param = [];
		var whereStmt =""
		var first = true;
		for (var key in condition) {
			if (!first) whereStmt +=" and ";
			if (key === '_id')
				whereStmt += "id=?";
			else
				whereStmt += key +"=?";
			first = false;
			param.push(condition[key]);
		}
		return {"whereStmt":whereStmt, "param":param};*)
		)
  )
  
)